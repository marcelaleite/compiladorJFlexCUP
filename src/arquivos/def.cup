package compiladorjflexcup;

import java.io.*;
import java_cup.runtime.*;
import compiladorjflexcup.Lexico;
import java.util.ArrayList;


action code {:  // incluir rotinas customizadas para manipular a tabela de símbolos
            :};

parser code
{:
    // colocar funções customizadas que serão utilizadas pelo parser
    // exemplo - tratamento de erros sintáticos

    //private Programa programa = new Programa();

    public void syntax_error(Symbol s){
        String strErro = "Erro de sintaxe. Linha: " + (s.right + 1) +
            " Coluna: " + s.left + ". Valor: \"" + s.value + "\"" + " \n Token Encontrado: " + sym.terminalNames[s.sym] + " state " + s.parse_state + "\n";
        
        report_error(strErro, null); 
        
    }
    public void semantico(Object tk){
       System.out.println("Semântico....");
    }
    
:};

init with {:  // código para ser executado antes de pegar o próximo token
              // pode ser usado para iniciar variáveis ou tabelas para o analisador semântico
           //  scanner.init();              
          :};


terminal SOMA, MULT, DIV, SUB, ATRIB, IGUAL, DIF, MAIORQ, MENORQ, MAIORI, MENORI,BOOLLITERAL,CADEIA, NAO, E, OU, ID, CONST, IF,ELSE, WHILE, ERRO, APAR, FPAR, STR, BOOL, INT, PV, PROG, INI, FIM, DEC;

non terminal Atribuicao ATT;
non terminal Expressao EXP;
non terminal Expressao QUO;
non terminal Expressao FATOR; 
non terminal Termo TERM2; 
non terminal Expressao TERM;
non terminal ArrayList<Comando> LISTA; 
non terminal Comando COMANDO; 
non terminal ExpressaoLogica EXPL;
non terminal OPREL;
non terminal Programa PROGRAMA;
non terminal Variavel DECLARACAO;
non terminal Tipo TIPO;

PROGRAMA ::= PROG ID INI LISTA:lst FIM    {: RESULT = new Programa(); RESULT.setLista(lst);:}
        ;
LISTA ::= COMANDO:c PV LISTA:l            {:  l.add(c); RESULT = l; :}  
        | COMANDO:c2 PV                   {: ArrayList<Comando> lst = new ArrayList<Comando>();lst.add(c2);RESULT = lst; :}
        ;
COMANDO ::= ATT:atribuicao                {: RESULT = new Comando(atribuicao);         :}
        | EXPL:expressao                  {: RESULT = new Comando(expressao);          :}
        | DECLARACAO:dec                  {: RESULT = new Comando(dec);                :}
        ;
DECLARACAO ::= DEC ID:var TIPO:tipo       {: RESULT = new Variavel(var,tipo);          :}
        ;
TIPO ::= INT                              {: RESULT = new Tipo();                      :}
        | CADEIA                          {: RESULT = new Tipo();                      :}
        | BOOL                            {: RESULT = new Tipo();                      :}
        ;
ATT ::= ID:id ATRIB EXP:expressao         {: RESULT = new Atribuicao(new Identificador(id),expressao);    :} 
        ;
EXP ::= EXP:exp DIV:div QUO:quo           {: RESULT = new Expressao(exp,div,quo);      :} 
       | QUO:quo                          {: RESULT = new Expressao(quo);              :}
       ; 
QUO ::= QUO:quo MULT:mult FATOR:fator     {: RESULT = new Expressao(quo,mult,fator);   :} 
       | FATOR:fator                      {: RESULT = new Expressao(fator);            :} 
       ;
FATOR ::= FATOR:fator SOMA:soma TERM:term {: RESULT = new Expressao(fator,soma,term);  :} 
       | TERM:term                        {: RESULT = new Expressao(term);             :} 
       ;
TERM ::= TERM:term SUB:sub TERM2:term2    {: RESULT = new Expressao(term,sub,term2);   :} 
       | TERM2:term2                      {: RESULT = new Expressao(term2);            :} 
       ;
TERM2 ::= ID:i                            {: RESULT = new Termo(new Identificador(i)); :}
      | CONST:c                           {: RESULT = new Termo(new Constante(c));     :}
      | STR:s                             {: RESULT = new Termo(new Str(s));           :}
      | BOOLLITERAL                       {: RESULT = new Termo(new Bool(s));
      ;
EXPL ::= TERM2:t1 OPREL:op TERM2:t2       {: RESULT = new ExpressaoLogica(t1,op,t2);   :}  
       ;
OPREL ::= IGUAL | DIF | MAIORQ | MENORQ | MAIORI | MENORI;


